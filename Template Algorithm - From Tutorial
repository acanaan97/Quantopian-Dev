from quantopian.algorithm import order_optimal_portfolio
from quantopian.algorithm import attach_pipeline, pipeline_output
from quantopian.pipeline import Pipeline
from quantopian.pipeline.data.builtin import USEquityPricing
from quantopian.pipeline.factors import SimpleMovingAverage
from quantopian.pipeline.filters import QTradableStocksUS
import quantopian.optimize as opt

def initialize(context):
    # Schedule our rebalance function to run at the start of
    # each week, when the market opens.
    schedule_function(
        my_rebalance,
        date_rules.week_start(),
        time_rules.market_open()
    )
    
    # Record variables at the end of each day.
    schedule_function(
        my_record_vars,
        date_rules.every_day(),
        time_rules.market_close()
    )
    
    my_pipe = make_pipeline()
    algo.attach_pipeline(my_pipe, 'my_pipeline')
    
def make_pipeline():
    base_universe = QTradableStocksUS()
    
    mean_close_10 = SimpleMovingAverage(
        inputs = [USEquityPricing.close],
        window_length = 10,
        mask = base_universe
    )
    
    mean_close_30 = SimpleMovingAverage(
        inputs = [USEquityPricing.close],
        window_length = 30,
        mask = base_universe
    )
    
    percent_difference = (sma_10 - sma_30) / sma_30
    
    shorts = percent_difference.top(75)

    longs = percent_difference.bottom(75)

    securities_to_trade = (shorts | longs)
    
    return Pipeline(
        columns={
            'Longs: ': longs,
            'Shorts: ': shorts
        },
        screen=(securities_to_trade)
    )

def compute_target_weights(context, data):
    # initialize empty target weights dictionary
    weights = {}
    
    # If there are securities in our longs and shorts lists,
    # compute even target weights for each security
    if context.longs and context.shorts:
        long_weight = 0.5 / len(context.longs)
        short_weight = -0.5 / len(context.shorts)
    else:
        return weights
    
    # Exit positions in our portfolio if they are not
    # in our long or short lists
    for security in context.portfolio.positions:
        if security not in context.longs and security not in context.shorts and data.can_trade(security):
            weights[security] = 0

    for security in context.longs:
        weights[security] = long_weight
        
    for security in context.shorts:
        weights[security] = short_weight
        
    return weights 

def before_trading_start(context, data):
    # Store our pipeline output DataFrame in context
    pipe_results = algo.pipeline_output('my_pipeline')
    
    # Go long in securities for which the 'longs' value is True,
    # and check if they can be traded.
    context.longs = []
    for sec in pipe_results[pipe_results['longs']].index.tolist():
        if data.can_trade(sec):
            context.longs.append(sec)
            
    # Go short in securities for which the 'shorts' value is True,
    # and check if they can be traded.
    context.shorts = []
    for sec in pipe_results[pipe_results['shorts']].index.tolist():
        if data.can_trade(sec):
            context.shorts.append(sec)
            
def my_rebalance(context, data):
    # Rebalance weekly
    # Calculate target weights to rebalance
    target_weights = compute_target_weights(context, data)
    
    if target_weights:
        algo.order_optimal_portfolio(
            objective=opt.TargetWeights(target_weights),
            constaints = [],
         )
        
def my_record_vars(context, data):
    
    
    long = shorts = 0
    for position in context.portfolio.positions.itervalues():
        if position.amount > 0:
            longs += 1
        elif position.amount < 0:
            shorts += 1
            
     # Record our variables
     record(
            leverage=context.account.leverage,
            long_count=longs,
            short_counts=shorts
     )
